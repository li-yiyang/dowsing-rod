#+title: Dowsing Rod
#+author: 凉凉
* About
Dowsing Rod is a simple map planning project.
Please note that it is mostly for personal (and learning)
interest. And this project is inspired by [[https://github.com/emacs-eaf/eaf-map][eaf-map]].

This project is in early development, so just use
your favorite Common Lisp REPL ([[https://github.com/joaotavora/sly/][SLY]] or [[https://github.com/slime/slime][SLIME]] or so),
load system =dowsing-rod=, jump into =:dowsing-rod-user=
package (=(in-package :dowsing-rod-user)=) and run
=(dowsing-rod-start)=.

Good luck.

* Project Conversion
** Naming Conversion
+ Constants in uppercase literally: =T=, =NIL=.
  
** File Structures
#+name: asdf-defsystem-dowsing-rod
#+headers: :tangle dowsing-rod.asd 
#+begin_src lisp
  ;;; dowsing-rod.asd

  (asdf:defsystem "dowsing-rod"
    :description ""
    :author "凉凉 <https://github.com/li-yiyang>"
    :license "MIT"
    :version "0.0.1"
    :depends-on ("clog"                   ; GUI
                 "dexador"                ; HTTP Client
                 "yason"                  ; JSON Paraser
                 "quri"                   ; URL Encoder
                 )
    :serial T
    :components ((:file "src/js-convert")
                 (:file "src/geojson")
                 (:file "src/nominatim")
                 (:file "src/clog-leaflet")
                 (:file "dowsing-rod")
                 (:file "dowsing-rod-user")))
#+end_src

* Dowsing Rod User
:PROPERTIES:
:header-args: :tangle dowsing-rod-user.lisp
:END:

#+name: defpackage-dowsing-rod-user
#+begin_src lisp
  ;;; dowsing-rod-user.lisp

  (defpackage #:dowsing-rod-user
    (:use #:dowsing-rod #:clog)
    (:export #:start-dowsing-rod)
    (:documentation "Feel free to use the Dowsing Rod."))
#+end_src

** Variables
#+name: dowsing-rod-user-variable-section
#+begin_src lisp
  ;;;;;;;;;;;;;;;;;
  ;;; Variables
  ;;;;;;;;;;;;;;;;;
#+end_src

+ =*map*=
  
  #+name: defparameter-map
  #+begin_src lisp
    (defparameter *map* NIL
      "The `leaflet-map' binding to Leaflet Map object.")
  #+end_src

** Start Dowsing Rod
#+name: defun-start-dowsing-rod
#+begin_src lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; Implementation - Start Dowsing Rod
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defun start-dowsing-rod (&optional (target 'BROWSER))
    "Start Dowsing Rod Application.

  The `target' should be:
  + `BROWSER' to open dowsing rod application in browser.

  It will bind a special global variable `*map*' as `leaflet-map' object."
    (initialize (lambda (body)
                  (set-margin body 0 0 0 0)
                  (let* ((window (window body))
                         (width  (width  window))
                         (height (height window))
                         (map    (create-map body :width width
                                                  :height height))
                         (tile-layer (create-tile-layer map)))
                    (set-on-resize window (lambda (win)
                                            (setf (width map) (width win)
                                                  (height map) (height win))))
                    (setf *map* map))))
    (cond ((eq target 'BROWSER) (open-browser))))
#+end_src

* Dowsing Rod
:PROPERTIES:
:header-args: :tangle dowsing-rod.lisp
:END:

#+name: defpackge-dowsing-rod
#+begin_src lisp
  ;;; dowsing-rod.lisp

  (defpackage #:dowsing-rod
    (:use #:cl #:clog #:clog-leaflet)
    (:export #:start-dowsing-rod)
    (:documentation "The dowsing rod is a map application."))

  (in-package :dowsing-rod)
#+end_src

** Variables
#+name: dowsing-rod-variables-section
#+begin_src lisp
  ;;;;;;;;;;;;;;;;;
  ;;; Variables
  ;;;;;;;;;;;;;;;;;
#+end_src
  
* JS Convert
:PROPERTIES:
:header-args: :tangle src/js-convert.lisp
:END:
This project uses [[https://github.com/rabbibotton/clog/][CLOG]] for GUI rendering, which needs
to convert Common Lisp data between JavaScript codes
literally.

#+name: defpackage-js-conversion
#+begin_src lisp
  ;;; JS Convert Package
  (defpackage #:js-convert
    (:use :cl)
    (:export #:wrapper
             #:merge-plist
             #:merge-alist
             #:->js
             #:plist->js
             #:alist->js
             #:generate-js-wrapper)
    (:documentation "Convert Common Lisp object to JavaScript Literally."))

  (in-package :js-convert)
#+end_src

** Helper Functions
#+name: js-convert-helper-function
#+begin_src lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; Helper Functions
  ;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

+ =wrapper=

  #+name: defun-wrapper
  #+begin_src lisp
    (defun wrapper (lst &key (left "[")
                          (right "]")
                          (spliter ", ")
                          (fn #'identity))
      "Wrap LST with LEFT and RIGHT, split element by SPLITER.
      The element will be mapped with FN function."
      (format NIL "~A~A~A"
              left
              (reduce (lambda (converted new)
                        (format NIL "~A~A~A"
                                converted spliter (funcall fn new)))
                      (rest lst)
                      :initial-value (funcall fn (first lst)))
              right))
  #+end_src
+ =merge-plist=

  #+name: defun-merge-plist
  #+begin_src lisp
    (defun merge-plist (p1 p2)
      "Merge two property list `p1' and `p2'."
      (let ((res (copy-list p2)))
        (loop for (key value) on p1 by #'cddr
              if (not (getf res key))
                do (progn (push value res)
                          (push key res)))
        res))
  #+end_src
+ =merge-alist=

  #+name: defun-merge-alist
  #+begin_src lisp
    (defun merge-alist (a1 a2)
      "Merge two association list `a1' and `a2'."
      (union a1 a2 :key #'car))
  #+end_src
+ =->js= Common Lisp → JavaScript (Literal)

  #+name: defgeneric-to-js
  #+begin_src lisp
    (defgeneric ->js (obj)
      (:documentation "Convert Common Lisp Object to JS code literally."))
  #+end_src

  Default by =(format NIL "~A")=:

  #+name: defmethod-to-js-default
  #+begin_src lisp
    (defmethod ->js (obj)
      "Default will be simply `format' function."
      (format NIL "~A" obj))
  #+end_src

  For built in data types:
  + Symbols =this-is-symbol= → ="thisIsSymbol"=

    There are two symbols need to be treat specially: =NIL= for ="false"=,
    =T= for ="true"=. For other symbols, change the dashed symbol name
    to Camel Cased name.

    #+name: defmethod-to-js-symbol
    #+begin_src lisp
      (defmethod ->js ((obj symbol))
        (cond ((eq obj T) "true")
              ((eq obj NIL) "false")
              (T (let ((char-list (coerce (string obj) 'list))
                       (upperp NIL))
                   (wrapper char-list
                            :left "" :right "" :spliter ""
                            :fn (lambda (char)
                                  (cond (upperp (setf upperp NIL)
                                                (string-upcase (string char)))
                                        ((eq char #\-) (setf upperp T) "")
                                        (T (string-downcase (string char))))))))))
    #+end_src
  + List =(a b c ...)= → ="[a, b, c]"=

    #+name: defmethod-to-js-list
    #+begin_src lisp
      (defmethod ->js ((obj list))
        (wrapper obj :fn #'->js))
    #+end_src
  + String ="..."= → ="\"...\""=

    #+name: defmethod-to-js-string
    #+begin_src lisp
      (defmethod ->js ((obj string))
        (format NIL "~S" obj))
    #+end_src
  + Hash Table → ="{key: value}"=

    #+name: defmethod-to-js-hash-table
    #+begin_src lisp
      (defmethod ->js ((obj hash-table))
        (wrapper (let ((res '()))
                   (maphash
                    (lambda (key value)
                      (push (format NIL "~A: ~A"
                                    (->js key)
                                    (->js value))
                            res))
                    obj)
                   res)
                 :left "{" :right "}"))
    #+end_src
+ =alist->js=

  #+name: defun-alist-to-js
  #+begin_src lisp
    (defun alist->js (alist)
      "Turn `alist' into JS Map literally."
      (wrapper (mapcar (lambda (pair)
                         (format NIL "~A: ~A"
                                 (->js (car pair))
                                 (->js (cdr pair))))
                       alist)
               :left "{"
               :right "}"))
  #+end_src
+ =plist->js=

  #+name: defun-plist-to-js
  #+begin_src lisp
    (defun plist->js (plist)
      "Turn `plist' into JS Map iterally."
      (if (null plist)
          "{}"
          (wrapper (loop for (key value) on plist by #'cddr
                         collect (format NIL "~A: ~A"
                                         (->js key) (->js value)))
                   :left "{"
                   :right "}")))
  #+end_src
+ =generate-js-wrapper=

  #+name: defmacro-generate-wrapper
  #+begin_src lisp
    (defmacro generate-js-wrapper (class &rest definitions)
      "The `definitions' should be like:

       (method-name (parameters) options)

    For example:
       (generate-js-wrapper example-class
         (example-method (parameters)
           :doc \"...\"))

    For `parameters' there two special keywords: `&optional',
    and `&key'. And the parameter name `key-options' is preseved. 

    For `options' it shoule be like a property list:
    + `:doc' for documentaion
    + `:js' for special JavaScript method name,
      default method name should be `(->js method-name)'."
      (labels ((mk-para-lst (paras)
                 (let ((para-lst '()))
                   (loop for para in paras do
                     (cond ((eq para '&key)
                            (push '&rest para-lst)
                            (push 'key-options para-lst)
                            (push para para-lst))
                           (T (push para para-lst))))
                   (reverse para-lst)))
               (flat-para-lst (paras)
                 (loop for para in paras
                       while (not (eq para '&key))
                       if (not (eq para '&optional))
                         collect (if (listp para)
                                     (first para)
                                     para)))
               (generate (definition)
                 (let* ((method    (first  definition))
                        (paras     (second definition))
                        (options   (cddr   definition))
                        (default-keys (let ((key-p NIL)
                                            (res '()))
                                        (loop for para in paras do
                                              (cond (key-p
                                                     (push (first para) res)
                                                     (push (second para) res))
                                                    ((eq para '&key)
                                                     (setf key-p T))))
                                        (reverse res)))
                        (para-lst  (mk-para-lst paras))
                        (option-p  (find 'key-options para-lst))
                        (flat-para (flat-para-lst paras))
                        (->js-para (cons '(->js obj)
                                         (mapcar (lambda (para)
                                                   `(->js ,para))
                                                 flat-para)))
                        (js-name   (getf options :js (->js method)))
                        (docstr    (getf options :doc
                                         (format NIL "<~A>.~A(~A~A)"
                                                 class
                                                 js-name
                                                 (wrapper flat-para
                                                          :left "" :right ""
                                                          :fn #'->js)
                                                 (if option-p ", options" "")))))
                   `((defgeneric ,method ,(cons 'obj
                                           (mapcar (lambda (para)
                                                     (if (listp para)
                                                         (first para)
                                                         para))
                                            para-lst))
                       (:documentation ,docstr))
                     (defmethod ,method ,(cons (list 'obj class) para-lst)
                       (declare ,(cons 'ignore
                                       (let ((res '())
                                             (key-p NIL))
                                         (loop for para in paras do
                                               (cond ((eq para '&key) (setf key-p T))
                                                     (key-p (push (if (listp para)
                                                                      (first para)
                                                                      para)
                                                                  res))))
                                         (reverse res))))
                       (clog:js-execute
                        obj
                        ,(append
                          `(format NIL
                                   ,(format NIL "~A.~A~A"
                                            "~A"
                                            js-name
                                            (wrapper (make-list (if option-p
                                                                    (1+ (length flat-para))
                                                                    (length flat-para))
                                                                :initial-element "~A")
                                                     :left "(" :right ")")))
                          (if option-p
                              (append ->js-para
                                      `((plist->js (merge-plist key-options
                                                                (quote ,default-keys)))))
                              ->js-para))))))))
        (cons 'progn (apply #'append (mapcar #'generate definitions)))))
  #+end_src
  
* Nominatim
:PROPERTIES:
:header-args: :tangle src/nominatim.lisp
:END:

#+begin_quote
Nominatim (from the Latin, 'by name') is a tool to search OSM data
by name and address and to generate synthetic addresses of OSM points
(reverse geocoding).
#+end_quote

#+name: defpackage-nominatim
#+begin_src lisp
  (defpackage #:nominatim
    (:use :cl :js-convert)
    (:export #:search-query))

  (in-package :nominatim)
#+end_src

** Constants
#+name: nominatim-constants-section
#+begin_src lisp
  ;;;;;;;;;;;;;;;;
  ;;; Constants
  ;;;;;;;;;;;;;;;;
#+end_src

+ Base URL

  #+name: defparameter-nominatim-host
  #+begin_src lisp
    (defparameter *nominatim-host*
      "https://nominatim.openstreetmap.org"
      "The base URL of Nominatim API.")
  #+end_src
+ Proxy

  #+name: defparameter-nominatim-proxy
  #+begin_src lisp
    (defparameter *nominatim-proxy* NIL
      "Proxy URL to use Nominatim API. Set `NIL' for no proxy.")
  #+end_src

  If you're struggling with network issue, please consider
  change the =*nominatim-host*= or set =*nominatim-proxy*=.
  For example, you can set by:

  #+name: example-set-proxy
  #+begin_src lisp :tangle no
    (setf *nominatim-proxy* "socks5://127.0.0.1:7890")
  #+end_src

  I was using [[http://phmarek.github.io/yason/][yason]] to make HTTP request (=dex:get= function),
  the proxy was specified via =:proxy= key.
+ Default Fetch Parameters

  #+name: defparameter-nominatim-fetch-parameters
  #+begin_src lisp
    (defparameter *nominatim-fetch-parameters*
      '(("format" . "geojson"))
      "Deafult fetch parameters.")
  #+end_src
  
** Method and Functions
#+name: nominatim-method-and-functions-section
#+begin_src lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; Method and Functions
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

+ =fetch=

  #+name: defun-fetch
  #+begin_src lisp
    (defun fetch (method parameters &key (proxy *nominatim-proxy*))
      "The general fetch method for wrap API usage."
      (let* ((url (quri:render-uri
                   (quri:make-uri
                    :defaults *nominatim-host*
                    :path method
                    :query (merge-alist parameters
                                        ,*nominatim-fetch-parameters*))))
             (res (if proxy
                      (dex:get url :proxy proxy)
                      (Dex:Get url))))
        (values (yason:parse res) res)))
  #+end_src
+ Search
  + =search-query=

    #+name: defun-search-query
    #+begin_src lisp
      (defun search-query (query &optional parameters (proxy *nominatim-proxy*))
        "Free form `query' string to search for. 

          Free-form queries are processed first left-to-right and then right-to-left 
          if that fails. So you may search for pilkington avenue, birmingham as well 
          as for birmingham, pilkington avenue. Commas are optional, but improve 
          performance by reducing the complexity of the search."
        (fetch "search"
               (merge-alist `(("q" . ,query))
                            parameters)
               :proxy proxy))
    #+end_src
  + =search-amenity=

    #+name: defun-search-amenity
    #+begin_src lisp
      (defun search-amenity (amenity &optional parameters (proxy *nominatim-proxy*))
        "`amenity' can be the name or type of POI."
        (fetch "search"
               (merge-alist `(("amenity" . ,amenity))
                            parameters)
               :proxy proxy))
    #+end_src
+ Reverse

  #+name: defun-reverse-search
  #+begin_src lisp
    (defun reverse-search (latitude longtitude &optional parameters
                                                 (proxy *nominatim-proxy*))
      "Reverse geocoding generates an address from a latitude and longitude."
      (fetch "reverse"
             (merge-alist `(("lat" . ,latitude)
                            ("lon" . ,longtitude))
                          parameters)
             :proxy proxy))
  #+end_src
  
* GeoJSON
:PROPERTIES:
:header-args: :tangle src/geojson.lisp
:END:

#+begin_quote
GeoJSON is a format for encoding a variety of geographic data structures.
#+end_quote

#+begin_src lisp
  ;;; src/geojson.lisp

  (defpackage #:geojson
    (:use :cl :js-convert)
    (:export #:->geo-obj #:->json))

  (in-package :geojson)
#+end_src

** Class Binding
#+name: geojson-class-binding-section
#+begin_src lisp
  ;;;;;;;;;;;;;;;;;;;;;
  ;;; Class Binding
  ;;;;;;;;;;;;;;;;;;;;;
#+end_src

#+begin_quote
GeoJSON supports the following geometry types: Point, LineString, Polygon,
MultiPoint, MultiLineString, and MultiPolygon. Geometric objects with
additional properties are Feature objects. Sets of features are contained
by FeatureCollection objects.
#+end_quote

#+name: defclass-geojson-object
#+begin_src lisp
  (defclass geojson-object ()
    ((geo-type :reader geo-type))
    (:documentation "The basic GeoJSON object."))
#+end_src

*** Geometric Object
#+name: defclass-geojson-geometric-object
#+begin_src lisp
  (defclass geojson-geometric-object (geojson-object)
    ((coordinates :initarg :coordinates
                  :accessor coordinates))
    (:documentation "Basic geometric object without additional properties."))
#+end_src

+ Point
  
  #+name: defclass-geojson-point
  #+begin_src lisp
    (defclass point (geojson-geometric-object)
      ((geo-type :initform "Point"))
      (:documentation "Point `coordinates' are `(longitude latitude)'."))
  #+end_src
+ LineString

  #+name: defclass-geojson-line-string
  #+begin_src lisp
    (defclass line-string (geojson-geometric-object)
      ((geo-type :initform "LineString"))
      (:documentation "LineString `coordinates' are a list of `(longitude latitude)'."))
  #+end_src
+ Polygon

  #+name: defclass-geojson-polygon
  #+begin_src lisp
    (defclass polygon (geojson-geometric-object)
      ((geo-type :initform "Polygon"))
      (:documentation "Polygon `coordinates' are list of linear ring coordinate arrays.
    The first element in the list is the `exterior-ring'; the second element in the
    list is the `interior-ring'."))
  #+end_src
+ MultiPoint

  #+name: defclass-geojson-multi-point
  #+begin_src lisp
    (defclass multi-point (geojson-geometric-object)
      ((geo-type :initform "MultiPolygon"))
      (:documentation "`multi-point' `coordinates' are list of `point' objects."))
  #+end_src
+ MultiLineString

  #+name: defclass-geojson-multi-line-string
  #+begin_src lisp
    (defclass multi-line-string (geojson-geometric-object)
      ((geo-type :initform "MultiLineString"))
      (:documentation "`multi-line-string' `coordinates' are list of `line-string' object."))
  #+end_src
+ MultiPolygon

  #+name: defclass-geojson-multi-polygon
  #+begin_src lisp
    (defclass multi-polygon (geojson-geometric-object)
      ((geo-type :initform "MultiPolygon"))
      (:documentation "`multi-polygon' `coordinates' are list of `polygon' object."))
  #+end_src
+ GeometryCollection

  #+name: defclass-geojson-geometry-collection
  #+begin_src lisp
    (defclass geometry-collection (geojson-geometric-object)
      ((geo-type :initform "GeometryCollection")
       (geometries :initarg :geometries
                   :type geojson-geometric-object
                   :accessor geometries))
      (:documentation "`geometries' are list of `geojson-geometric-object'."))
  #+end_src
  
*** Geometric Object with additional properties
#+name: defclass-geojson-feature-object
#+begin_src lisp
  (defclass feature (geojson-object)
    ((geo-type :initform "Feature")
     (geometry :initarg :geometry
               :accessor geometry)
     (bbox :initarg :bbox
           :accessor bbox)
     (properties :initarg :properties
                 :accessor properties)))

  (defclass feature-collection (geojson-object)
    ((geo-type :initform "FeatureCollection")
     (bbox :initarg :bbox
           :accessor bbox)
     (features :initarg :features
               :accessor features))
    (:documentation "`feature-collection' is a collection of `feautre'."))
#+end_src

** Method and Functions
#+name: geojson-method-and-functions-section
#+begin_src lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; Method and Functions
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

+ =hash-table->geometric-object=

  #+name: defun-hash-table-to-geometric-object
  #+begin_src lisp
    (defun hash-table->geometric-object (dat)
      "Turn `dat' into `geojson-geometric-object'."
      (declare (type hash-table dat))
      (let ((type (gethash "type" dat)))
        (make-instance
         (cond ((string= type "Point")           'point)
               ((string= type "LineString")      'line-string)
               ((string= type "Polygon")         'polygon)
               ((string= type "MultiPoint")      'multi-point)
               ((string= type "MultiLineString") 'multi-line-string)
               ((string= type "MultiPolygon")    'multi-polygon))
         :coordinates (gethash "coordinates" dat))))
  #+end_src
+ =hash-table->geometric-collection=

  #+name: defun-hash-table-to-geometric-collection
  #+begin_src lisp
    (defun hash-table->geometry-collection (dat) ;
      "Turn `dat' into `geometry-collection'."
      (declare (type hash-table dat))
      (make-instance 'geometry-collection
                     :geometries (mapcar #'hash-table->geometric-object
                                         (gethash "geometries" dat))))
  #+end_src
+ =hash-table->feature=

  #+name: defun-hash-table-to-feature
  #+begin_src lisp
    (defun hash-table->feature (dat)
      "Turn `dat' into `feature'."
      (declare (type hash-table dat))
      (let ((bbox     (gethash "bbox" dat))
            (geometry (hash-table->geometric-object
                       (gethash "geometry" dat)))
            (properties (gethash "properties" dat)))
        (make-instance 'feature
                       :bbox bbox
                       :properties properties
                       :geometry geometry)))
  #+end_src
+ =hash-table->feature-collection=

  #+name: defun-hash-table-to-feature-collection
  #+begin_src lisp
    (defun hash-table->feature-collection (dat)
      "Turn `dat' into `feature-collection'."
      (declare (type hash-table dat))
      (let ((bbox (gethash "bbox" dat))
            (features (mapcar #'hash-table->feature
                              (gethash "features" dat))))
        (make-instance 'feature-collection
                       :bbox bbox
                       :features features)))
  #+end_src
+ =->geo-obj=

  #+name: defun-to-geo-obj
  #+begin_src lisp
    (defun ->geo-obj (dat)
      (declare (type hash-table dat))
      (let ((type (gethash "type" dat)))
        (cond ((string= type "Feature")
               (hash-table->feature dat))
              ((string= type "FeatureCollection")
               (hash-table->feature-collection dat))
              ((string= type "GeometryCollection")
               (hash-table->geometry-collection dat)))))
  #+end_src
+ =->js=, =->json=

  #+name: defun-to-json
  #+begin_src lisp
    (defun ->json (obj)
      "Turn `obj' into JSON form. Same as `->js'."
      (->js obj))
  #+end_src
  + Geometric Object
    
    #+name: defmethod-to-js-geometric-object
    #+begin_src lisp
      (defmethod ->js ((obj geojson-geometric-object))
        (format NIL "{\"type\": ~A, \"coordinates\": ~A}"
                (->js (geo-type obj))
                (->js (coordinates obj))))
    #+end_src
  + GeometryCollection

    #+name: defmethod-to-js-geometry-collection
    #+begin_src lisp
      (defmethod ->js ((obj geometry-collection))
        (format NIL "{\"type\": \"GeometryCollection\", \"geometries\": ~A}"
                (->js (geometries obj))))
    #+end_src
  + Feature

    #+name: defmethod-to-js-feature
    #+begin_src lisp
      (defmethod ->js ((obj feature))
        (format NIL "{\"type\": \"Feature\", \"geometry\": ~A, \"properties\": ~A}"
                (->js (geometry obj))
                (->js (properties obj))))
    #+end_src
  + FeatureCollection

    #+name: defmethod-to-js-feature-collection
    #+begin_src lisp
      (defmethod ->js ((obj feature-collection))
        (format NIL "{\"type\": \"Feature\", \"features\": ~A}"
                (->js (features obj))))
    #+end_src
* CLOG Leaflet Binding
:PROPERTIES:
:header-args: :tangle src/clog-leaflet.lisp
:END:

#+name: defpackage-clog-leaflet
#+begin_src lisp
  (defpackage #:clog-leaflet
    (:use #:cl #:clog #:js-convert)
    (:export #:create-map
             #:create-tile-layer)
    (:documentation "This is CLOG Wrapper for Leaflet."))

  (in-package :clog-leaflet)
#+end_src

** Constants
#+name: clog-leaflet-constants-section
#+begin_src lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; Constant Variables
  ;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

*** Leaflet Name Space
#+name: defparameter-leaflet-namespace
#+begin_src lisp
  ;;; Leaflet Name Space

  (defparameter *leaflet-namespace*
    "window.LeafletNameSpace"
    "Name Space to store the Leaflet objects. 
  Leaflet objects can be referred by:
    <leaflet-namespace>['<class>-<id>'] 
  in JS code.")
#+end_src

*** Leaflet Variable
#+name: clog-leaflet-variable-section
#+begin_src lisp
  ;;; Leaflet Variable
#+end_src

+ CSS Path

  #+name: defparameter-css-path
  #+begin_src lisp
    (defparameter *leaflet-css-path*
      "https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      "Path/URL to Leaflet CSS file.")
  #+end_src
+ JS Path

  #+name: defparameter-js-path
  #+begin_src lisp
    (defparameter *leaflet-js-path*
      "https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      "Path/URL to Leaflet Javascript file.")
  #+end_src
+ Leaflet Map Default Parameters

  #+name: defparameter-leaflet-map-default-parameters
  #+begin_src lisp
    (defparameter *default-map-center* '(51.505 -0.09)
      "Default `leaflet-map' center position.")

    (defparameter *default-map-zoom* 13
      "Default `leaflet-map' zoom rate.")

    (defparameter *default-zoom-ratio* 1
      "Default `zoom-ratio' for `zoom-in' and `zoom-out'.")
  #+end_src
+ Tile Layer

  #+name: defparameter-tile-layer
  #+begin_src lisp
    (defparameter *default-tile-layer-url*
      "https://tile.openstreetmap.org/{z}/{x}/{y}.png"
      "Default Tile Layer URL.")

    (defparameter *default-tile-layer-attribution*
      "&copy; <a href='https://www.openstreetmap.org/copyright'>OpenStreetMap</a> contributors"
      "Default Tile Layer Attribution.")
  #+end_src
  
** CLOG Leaflet Functions
#+name: clog-leaflet-clog-leaflet-functions-section
#+begin_src lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; CLOG Leaflet Functions
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

+ =init-leaflet=
  
  #+name: defun-init-leaflet
  #+begin_src lisp
    (defun init-leaflet (body)
      "Load the Leaflet Javascripts and opens Leaflet Namespace. 
    It should be only called once or for earsing the Leaflet."
      (load-css    (html-document body)
                   ,*leaflet-css-path*
                   :load-only-once T)
      (load-script (html-document body)
                   ,*leaflet-js-path*
                   :load-only-once T
                   :wait-for-load NIL)
      (js-execute body (format NIL "if (!(~A)) { ~A = {}; }"
                               ,*leaflet-namespace*
                               ,*leaflet-namespace*)))
  #+end_src

** CLOG Classes
#+name: clog-leaflet-clog-classes
#+begin_src lisp
  ;;;;;;;;;;;;;;;;;;;;
  ;;; CLOG Classes
  ;;;;;;;;;;;;;;;;;;;;
#+end_src

#+name: defclass-leaflet-obj
#+begin_src lisp
  (defclass leaflet-obj ()
    ((leaflet-id   :initarg :leaflet-id
                   :initform (gensym "")
                   :reader leaflet-id))
    (:documentation "Basic Leaflet Object class."))
#+end_src

+ Leaflet-Map
  
  #+name: defclass-clog-leaflet
  #+begin_src lisp
    (defclass leaflet-map (clog-div leaflet-obj) ()
      (:documentation "`leaflet-map' object bind to Leaflet Map object.
    The `leaflet-map' object should act like a `clog-div' object."))
  #+end_src
+ Leaflet-Layer

  #+name: defclass-clog-leaflet-layer
  #+begin_src lisp
    (defclass leaflet-layer (leaflet-obj) ()
      (:documentation "Leaflet Layer class binding."))
  #+end_src
  + Tile Layer

    #+name: defclass-clog-leaflet-tile-layer
    #+begin_src lisp
      (defclass leaflet-tile-layer (leaflet-layer)
        ((url :initarg :url
              :reader url)
         (attribution :initarg :attribution
                      :reader attribution))
        (:documentation "Used to load and display tile layers on the map."))
    #+end_src
    
**** Method and Functions
#+name: clog-leaflet-method-and-functions
#+begin_src lisp
  ;;; Method and Functions
#+end_src

+ =create-map=

  #+name: def-create-map
  #+begin_src lisp
    (defgeneric create-map (clog-obj &key center zoom width height
                                       style class html-id)
      (:documentation "Create a new `clog-leaflet' object on `clog-obj'.
    The key parameters are described as below:
    + `center' the center position of `leaflet-map'. 
      It should be like `(longitude latitude)'.
    + `zoom' the zoom level of `leaflet-map'.
    + `width' and `height' is the size of `leaflet-map'.
      See more for `clog-div' properties.
    + `style', `class', `html-id' are same as `create-div'."))

    (defmethod create-map ((obj clog-obj) &key (center *default-map-center*)
                                            (zoom *default-map-zoom*)
                                            (width "400px")
                                            (height "400px")
                                            (style NIL)
                                            (class NIL)
                                            (html-id NIL))
      (let ((map (create-div obj :html-id html-id
                                 :class class
                                 :style style)))
        (init-leaflet obj)
        (change-class map 'leaflet-map)
        (setf (width map) width
              (height map) height)
        (js-execute
         map
         (format NIL "~A = L.map('~A', ~A)"
                 (->js map)
                 (html-id map)
                 (alist->js `((center . ,center)
                              (zoom   . ,zoom)))))))
  #+end_src
+ =add-tile-layer=

  #+name: def-add-tile-layer
  #+begin_src lisp
    (defgeneric create-tile-layer (map &key url attribution)
      (:documentation "Add Tile Layer to `map'. Return `leaflet-tile-layer' object."))

    (defmethod create-tile-layer ((map leaflet-map) &key (url *default-tile-layer-url*)
                                                   (attribution *default-tile-layer-attribution*))
      (let ((tile-layer (make-instance 'leaflet-tile-layer
                                       :url url
                                       :attribution attribution)))
        (js-execute map (format NIL "~A = L.tileLayer(~A, ~A).addTo(~A)"
                                (->js tile-layer)
                                (->js (url tile-layer))
                                (plist->js (list :attribution (attribution tile-layer)))
                                (->js map)))))
  #+end_src
+ =->js=

  #+name: defmethod-to-js-leaflet-map
  #+begin_src lisp
    (defmethod ->js ((obj leaflet-obj))
      (format NIL "~A['~A-~A']"
              ,*leaflet-namespace*
              (type-of obj)
              (leaflet-id obj)))
  #+end_src
  
**** JS Wrapper
#+name: clog-leaflet-js-wrapper-section
#+begin_src lisp
  ;;; JS Wrapper
#+end_src

+ =leaflet-map=
  
  #+name: generate-js-wrapper-leaflet-map
  #+begin_src lisp
    (generate-js-wrapper
     leaflet-map
     (fly-to (lat-lng zoom &key (animate T) (duration 1))
             :doc "Sets the view of the map performing a smooth pan-zoom animation.")
     (set-view (lat-lng zoom &key (animate T)
                        (duration 0.5))
               :doc "Sets the view of the `leaflet-map' of `lat-lng' and `zoom' with options.
    The `lat-lng' should be like `(latitude longitude)'. 
    The options are described below:
    + `animate': If `T', panning will always be animated if possible. 
    + `duration': Duration of animated panning, in seconds.")
     (set-zoom (zoom)
               :doc "Sets the zoom of the map.")
     (zoom-in (&optional (zoom-ratio *default-zoom-ratio*))
              :doc "Increases the zoom of the map by `zoom-in'.")
     (zoom-out (&optional (zoom-ratio *default-zoom-ratio*))
               :doc "Decreases the zoom of the map by `zoom-ratio'."))
  #+end_src
+ =leaflet-layer=

  #+name: generate-js-wrapper-leaflet-layer
  #+begin_src lisp
    (generate-js-wrapper
     leaflet-layer)
  #+end_src
  
* Others
** License
#+name: mit-license
#+header: :tangle LICENSE
#+begin_src text
  MIT License

  Copyright (c) 2023 凉凉

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
#+end_src
* COMMENT LocalWords
#  LocalWords:  Nominatim GeoJSON LineString MultiPoint MultiPolygon
#  LocalWords:  MultiLineString FeatureCollection OSM geocoding
#  LocalWords:  GeometryCollection
